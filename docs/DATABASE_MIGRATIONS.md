# Database Migrations Guide

Comprehensive guide for managing database migrations in Jocular Kangaroo using Drizzle ORM.

## Table of Contents
- [Overview](#overview)
- [Creating New Migrations](#creating-new-migrations)
- [Migration Execution](#migration-execution)
- [Troubleshooting](#troubleshooting)
- [Rollback Procedures](#rollback-procedures)
- [Monitoring](#monitoring)
- [Best Practices](#best-practices)

## Overview

### Migration System
Jocular Kangaroo uses **Drizzle ORM** for database migrations with the following architecture:

- **Local Development**: Migrations are generated from TypeScript schema definitions in `/src/db/schema.ts`
- **Production**: AWS Lambda executes migrations during CDK deployments
- **Tracking**: Drizzle maintains a `drizzle_migrations` table to track applied migrations
- **Idempotency**: Each migration runs exactly once, even if Lambda is invoked multiple times

### Key Components
1. **Schema Definition**: `/src/db/schema.ts` - TypeScript schema using Drizzle ORM
2. **Generated Migrations**: `/drizzle/*.sql` - SQL files generated by Drizzle Kit
3. **Lambda Handler**: `/infra/database/lambda/index.ts` - Executes migrations in AWS
4. **CloudWatch Logs**: Structured JSON logs for monitoring and debugging

## Creating New Migrations

### Step 1: Update Schema
Edit the TypeScript schema in `/src/db/schema.ts`:

```typescript
import { pgTable, serial, varchar, timestamp } from "drizzle-orm/pg-core";

export const newTable = pgTable("new_table", {
  id: serial("id").primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});
```

### Step 2: Generate Migration
Run the Drizzle Kit generator:

```bash
npm run db:generate
```

This creates a new migration file in `/drizzle/` with a timestamp and auto-generated name:
```
/drizzle/0006_smart_wolverine.sql
```

### Step 3: Review Migration
**Always review the generated SQL before committing!**

```bash
cat drizzle/0006_smart_wolverine.sql
```

Verify:
- ✅ Column types are correct
- ✅ Constraints are appropriate
- ✅ Foreign keys reference the right tables
- ✅ No unintended changes

### Step 4: Test Locally (Optional)
Push directly to your development database to test:

```bash
npm run db:push
```

⚠️ **Warning**: `db:push` doesn't use migrations - it syncs schema directly. Only use for local testing.

### Step 5: Commit Migration
Once verified, commit the migration file:

```bash
git add drizzle/0006_smart_wolverine.sql
git add drizzle/meta/0006_snapshot.json
git commit -m "feat: add new_table for tracking XYZ"
```

## Migration Execution

### Development Environment
Migrations run automatically when you deploy the DatabaseStack:

```bash
cd infra
npx cdk deploy JocularKangaroo-DatabaseStack-Dev
```

The Lambda function:
1. Reads all migration files from `/drizzle/` folder
2. Checks `drizzle_migrations` table for already-applied migrations
3. Executes new migrations in alphabetical order
4. Updates tracking table with execution status

### Production Environment
Same process, but with production stack:

```bash
cd infra
npx cdk deploy JocularKangaroo-DatabaseStack-Prod
```

### CloudFormation Integration
Migrations are triggered by a CloudFormation Custom Resource:
- **On Create**: Runs all migrations
- **On Update**: Runs new migrations only
- **On Delete**: No action (migrations are not rolled back)

## Troubleshooting

### Finding Logs
Migrations are logged to CloudWatch Logs:

```bash
# Get latest log stream
aws logs describe-log-streams \
  --log-group-name /aws/lambda/JocularKangaroo-DatabaseMigration-Dev \
  --order-by LastEventTime \
  --descending \
  --limit 1

# View logs
aws logs get-log-events \
  --log-group-name /aws/lambda/JocularKangaroo-DatabaseMigration-Dev \
  --log-stream-name <stream-name-from-above>
```

Or use the AWS Console:
1. Navigate to CloudWatch → Logs → Log Groups
2. Find `/aws/lambda/JocularKangaroo-DatabaseMigration-{Env}`
3. Click latest log stream

### Common Error Categories

#### SECURITY_VIOLATION
**Cause**: Path traversal or invalid migration filename detected

**Example**:
```json
{
  "level": "ERROR",
  "category": "SECURITY_VIOLATION",
  "message": "Security: Invalid characters in migration filename: ../etc/passwd.sql"
}
```

**Solution**: Ensure migration filenames only contain alphanumeric characters, underscores, and `.sql` extension.

---

#### RESOURCE_NOT_FOUND
**Cause**: Migrations folder missing or empty

**Example**:
```json
{
  "level": "ERROR",
  "category": "RESOURCE_NOT_FOUND",
  "message": "Migrations folder not found at /var/task/drizzle"
}
```

**Solution**:
1. Verify migrations are bundled in Lambda deployment
2. Check CDK bundling configuration in `database-stack.ts`
3. Ensure `drizzle/` folder exists in project root

---

#### SQL_SYNTAX_ERROR
**Cause**: Invalid SQL in migration file

**Example**:
```json
{
  "level": "ERROR",
  "category": "SQL_SYNTAX_ERROR",
  "message": "syntax error at or near \"CRATE\""
}
```

**Solution**:
1. Review the migration SQL file
2. Test locally with `npm run db:push`
3. Fix syntax and regenerate migration
4. Commit corrected version

---

#### PERMISSION_DENIED
**Cause**: Lambda lacks IAM permissions for RDS Data API or Secrets Manager

**Example**:
```json
{
  "level": "ERROR",
  "category": "PERMISSION_DENIED",
  "message": "User does not have permission to access secret"
}
```

**Solution**:
1. Verify Lambda has `rds-data:ExecuteStatement` permission
2. Verify Lambda has `secretsmanager:GetSecretValue` permission
3. Check IAM role in `database-stack.ts`:
   ```typescript
   cluster.grantDataApiAccess(dbInitLambda);
   dbSecret.grantRead(dbInitLambda);
   ```

---

#### NETWORK_ERROR
**Cause**: Lambda cannot connect to database

**Example**:
```json
{
  "level": "ERROR",
  "category": "NETWORK_ERROR",
  "message": "Connection timeout after 30000ms"
}
```

**Solution**:
1. Verify database is running: Check RDS console
2. Check VPC configuration if applicable
3. Verify Data API is enabled on the cluster
4. Check security group rules

## Rollback Procedures

### Understanding Drizzle Migration Tracking
Drizzle ORM **does not support automatic rollback**. Once a migration is applied, it's recorded in the `drizzle_migrations` table:

```sql
SELECT * FROM drizzle_migrations ORDER BY created_at DESC;
```

| id | hash | created_at |
|----|------|------------|
| 6  | abc123... | 2025-01-15 10:30:00 |
| 5  | def456... | 2025-01-14 09:15:00 |

### Manual Rollback Options

#### Option 1: Write a Reverse Migration (Recommended)
Create a new migration that undoes the changes:

```bash
# If you added a table, drop it
echo "DROP TABLE IF EXISTS new_table;" > drizzle/0007_rollback_new_table.sql

# Or if you added a column, remove it
echo "ALTER TABLE users DROP COLUMN IF EXISTS new_column;" > drizzle/0007_rollback_new_column.sql
```

Then deploy:
```bash
cd infra && npx cdk deploy JocularKangaroo-DatabaseStack-Dev
```

#### Option 2: Direct Database Access (Emergency Only)
⚠️ **Use with extreme caution!**

```bash
# Install psql client locally
brew install postgresql

# Connect via Data API is not available for interactive sessions
# You must use Systems Manager Session Manager or a bastion host

# 1. Via SSM (if configured):
aws ssm start-session --target <instance-id>

# 2. Then connect to RDS:
psql -h <cluster-endpoint> -U master -d jocular_kangaroo

# 3. Manually revert changes:
BEGIN;
-- Your rollback SQL here
DROP TABLE new_table;
-- Remove from tracking table
DELETE FROM drizzle_migrations WHERE hash = 'abc123...';
COMMIT;
```

#### Option 3: Database Snapshot Restore
For catastrophic failures:

1. Identify last good snapshot:
   ```bash
   aws rds describe-db-cluster-snapshots \
     --db-cluster-identifier jocular-kangaroo-dev \
     --snapshot-type automated
   ```

2. Restore from snapshot:
   ```bash
   aws rds restore-db-cluster-from-snapshot \
     --db-cluster-identifier jocular-kangaroo-dev-restored \
     --snapshot-identifier <snapshot-id>
   ```

3. Update CDK to point to restored cluster (coordinate with infrastructure team)

### Handling Partial Failures

If a migration fails partway through:

1. **Check migration table**:
   ```sql
   SELECT * FROM drizzle_migrations;
   ```

2. **Identify which migration failed**: Check CloudWatch logs for the specific file

3. **Assess database state**:
   ```sql
   -- Check what tables/columns exist
   \dt
   \d table_name
   ```

4. **Options**:
   - If migration didn't start: Fix migration file and redeploy
   - If migration partially applied: Manually complete or revert, update tracking table
   - If database is corrupted: Restore from snapshot

## Monitoring

### CloudWatch Metrics
The Lambda handler logs structured metrics:

```json
{
  "level": "INFO",
  "message": "Drizzle migrations completed successfully",
  "migrationDuration": 2341,
  "totalDuration": 2567,
  "filesProcessed": 3,
  "environment": "dev"
}
```

### Key Metrics to Monitor
1. **Migration Duration**: Total time to run all migrations
2. **Files Processed**: Number of migration files applied
3. **Error Rate**: Frequency of `FAILED` status
4. **Error Categories**: Distribution of error types

### CloudWatch Insights Queries

**Average migration duration**:
```
fields @timestamp, migrationDuration
| filter level = "INFO" and message = "Drizzle migrations completed successfully"
| stats avg(migrationDuration) as avg_duration by bin(1h)
```

**Error summary**:
```
fields @timestamp, category, message
| filter level = "ERROR"
| stats count() by category
```

**Recent migration history**:
```
fields @timestamp, filesProcessed, duration, environment
| filter message = "Drizzle migrations completed successfully"
| sort @timestamp desc
| limit 20
```

## Best Practices

### 1. Always Review Generated Migrations
Drizzle Kit is smart, but not perfect. Manually verify:
- Column types match your intent
- Indexes are created where needed
- Foreign key constraints are correct
- Data migration logic is safe

### 2. Test Migrations Locally First
```bash
# Push to local dev database to test
npm run db:push

# Or run migrations against a test database
DATABASE_URL=postgresql://localhost:5432/test npm run db:migrate
```

### 3. Avoid Destructive Changes
Prefer additive changes over destructive ones:
- ✅ Add new columns with defaults
- ✅ Create new tables
- ⚠️ Drop columns (data loss!)
- ⚠️ Change column types (may fail with existing data)
- ⚠️ Drop tables (data loss!)

### 4. Handle Large Data Migrations Carefully
For migrations that update millions of rows:

```sql
-- BAD: Updates everything in one transaction
UPDATE users SET status = 'active' WHERE status IS NULL;

-- GOOD: Batch updates
DO $$
DECLARE
  batch_size INT := 1000;
  affected_rows INT;
BEGIN
  LOOP
    UPDATE users SET status = 'active'
    WHERE id IN (
      SELECT id FROM users
      WHERE status IS NULL
      LIMIT batch_size
    );

    GET DIAGNOSTICS affected_rows = ROW_COUNT;
    EXIT WHEN affected_rows = 0;

    COMMIT;
  END LOOP;
END $$;
```

### 5. Coordinate Deployments with Team
When multiple developers create migrations simultaneously:

1. **Pull latest before generating**:
   ```bash
   git pull origin dev
   npm run db:generate
   ```

2. **Check for conflicts**:
   ```bash
   ls -la drizzle/
   # Look for migrations with similar timestamps
   ```

3. **If conflict exists**, rename your migration:
   ```bash
   mv drizzle/0006_xxx.sql drizzle/0007_xxx.sql
   # Update meta file accordingly
   ```

### 6. Document Complex Migrations
Add comments to migration SQL for future reference:

```sql
-- Migration: Add user preferences table
-- Author: John Doe
-- Date: 2025-01-15
-- Purpose: Store user UI preferences and settings
-- Related: Issue #123

CREATE TABLE user_preferences (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id),
  theme VARCHAR(50) DEFAULT 'light',
  notifications_enabled BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW() NOT NULL
);

-- Index for fast user lookups
CREATE INDEX idx_user_preferences_user_id ON user_preferences(user_id);
```

### 7. Backup Before Risky Migrations
Before deploying potentially risky migrations to production:

```bash
# Create manual snapshot
aws rds create-db-cluster-snapshot \
  --db-cluster-identifier jocular-kangaroo-prod \
  --db-cluster-snapshot-identifier manual-before-migration-$(date +%Y%m%d-%H%M%S)
```

### 8. Use Transactions
Drizzle runs migrations in transactions by default, but you can also wrap multiple statements:

```sql
BEGIN;

-- All or nothing
CREATE TABLE new_table (...);
ALTER TABLE old_table ADD COLUMN ...;
CREATE INDEX ...;

COMMIT;
```

### 9. Test Rollback Procedures
Practice rollback on dev/staging before production deployment:

```bash
# Deploy migration
cd infra && npx cdk deploy JocularKangaroo-DatabaseStack-Dev

# Verify it works
# ...

# Test rollback procedure
# Create reverse migration and deploy
```

### 10. Monitor After Deployment
After deploying migrations to production:

1. ✅ Check CloudWatch logs for success
2. ✅ Verify application functionality
3. ✅ Monitor error rates in APM tools
4. ✅ Check database performance metrics
5. ✅ Have rollback plan ready

---

## Quick Reference

### Commands
```bash
# Generate migration from schema changes
npm run db:generate

# Push schema directly (dev only)
npm run db:push

# Pull schema from database
npm run db:pull

# Open Drizzle Studio (database GUI)
npm run db:studio

# Deploy migrations (dev)
cd infra && npx cdk deploy JocularKangaroo-DatabaseStack-Dev

# Deploy migrations (prod)
cd infra && npx cdk deploy JocularKangaroo-DatabaseStack-Prod
```

### File Locations
- **Schema**: `/src/db/schema.ts`
- **Migrations**: `/drizzle/*.sql`
- **Lambda Handler**: `/infra/database/lambda/index.ts`
- **Lambda Logger**: `/infra/database/lambda/logger.ts`
- **CDK Stack**: `/infra/lib/database-stack.ts`

### Important Tables
- **Migration Tracking**: `drizzle_migrations`
- **Check Applied Migrations**: `SELECT * FROM drizzle_migrations ORDER BY created_at;`

### CloudWatch Log Groups
- Dev: `/aws/lambda/JocularKangaroo-DatabaseMigration-Dev`
- Prod: `/aws/lambda/JocularKangaroo-DatabaseMigration-Prod`

---

**Questions or Issues?** Contact the infrastructure team or create an issue in the repository.